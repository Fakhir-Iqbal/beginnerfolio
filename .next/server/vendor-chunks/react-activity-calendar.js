"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/react-activity-calendar";
exports.ids = ["vendor-chunks/react-activity-calendar"];
exports.modules = {

/***/ "(ssr)/./node_modules/react-activity-calendar/build/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/react-activity-calendar/build/index.js ***!
  \*************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("/* __next_internal_client_entry_do_not_use__  cjs */ \nObject.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nvar chroma = __webpack_require__(/*! chroma-js */ \"(ssr)/./node_modules/chroma-js/chroma.js\");\nvar dateFns = __webpack_require__(/*! date-fns */ \"(ssr)/./node_modules/date-fns/index.mjs\");\nvar React = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\nfunction _interopDefault(e) {\n    return e && e.__esModule ? e : {\n        default: e\n    };\n}\nvar chroma__default = /*#__PURE__*/ _interopDefault(chroma);\nvar React__default = /*#__PURE__*/ _interopDefault(React);\nfunction _extends() {\n    return _extends = Object.assign ? Object.assign.bind() : function(n) {\n        for(var e = 1; e < arguments.length; e++){\n            var t = arguments[e];\n            for(var r in t)({}).hasOwnProperty.call(t, r) && (n[r] = t[r]);\n        }\n        return n;\n    }, _extends.apply(null, arguments);\n}\nconst NAMESPACE = \"react-activity-calendar\";\nconst LABEL_MARGIN = 8; // px\nconst DEFAULT_MONTH_LABELS = [\n    \"Jan\",\n    \"Feb\",\n    \"Mar\",\n    \"Apr\",\n    \"May\",\n    \"Jun\",\n    \"Jul\",\n    \"Aug\",\n    \"Sep\",\n    \"Oct\",\n    \"Nov\",\n    \"Dec\"\n];\nconst DEFAULT_LABELS = {\n    months: DEFAULT_MONTH_LABELS,\n    weekdays: [\n        \"Sun\",\n        \"Mon\",\n        \"Tue\",\n        \"Wed\",\n        \"Thu\",\n        \"Fri\",\n        \"Sat\"\n    ],\n    totalCount: \"{{count}} activities in {{year}}\",\n    legend: {\n        less: \"Less\",\n        more: \"More\"\n    }\n};\nfunction useColorScheme() {\n    const [colorScheme, setColorScheme] = React.useState(\"light\");\n    const onChange = (event)=>setColorScheme(event.matches ? \"dark\" : \"light\");\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(\"(prefers-color-scheme: dark)\");\n        setColorScheme(mediaQuery.matches ? \"dark\" : \"light\");\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return colorScheme;\n}\nfunction useIsClient() {\n    const [isClient, setClient] = React.useState(false);\n    React.useEffect(()=>{\n        setClient(true);\n    }, []);\n    return isClient;\n}\nconst query = \"(prefers-reduced-motion: reduce)\";\nfunction usePrefersReducedMotion() {\n    const [prefersReducedMotion, setPrefersReducedMotion] = React.useState(true);\n    React.useEffect(()=>{\n        const mediaQuery = window.matchMedia(query);\n        setPrefersReducedMotion(mediaQuery.matches);\n        const onChange = (event)=>{\n            setPrefersReducedMotion(event.matches);\n        };\n        mediaQuery.addEventListener(\"change\", onChange);\n        return ()=>{\n            mediaQuery.removeEventListener(\"change\", onChange);\n        };\n    }, []);\n    return prefersReducedMotion;\n}\nfunction styleInject(css, ref) {\n    if (ref === void 0) ref = {};\n    var insertAt = ref.insertAt;\n    if (typeof document === \"undefined\") {\n        return;\n    }\n    var head = document.head || document.getElementsByTagName(\"head\")[0];\n    var style = document.createElement(\"style\");\n    style.type = \"text/css\";\n    if (insertAt === \"top\") {\n        if (head.firstChild) {\n            head.insertBefore(style, head.firstChild);\n        } else {\n            head.appendChild(style);\n        }\n    } else {\n        head.appendChild(style);\n    }\n    if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        style.appendChild(document.createTextNode(css));\n    }\n}\nvar css_248z = \".styles-module_container__GBNxC {\\n  width: max-content; /* Calendar should not grow */\\n  max-width: 100%; /* Do not remove - flexbox parents */\\n  display: flex;\\n  flex-direction: column;\\n  gap: 8px;\\n}\\n\\n.styles-module_container__GBNxC rect {\\n  stroke: rgba(0, 0, 0, 0.08);\\n  stroke-width: 1px;\\n  shape-rendering: geometricPrecision;\\n}\\n\\n@media (prefers-color-scheme: dark) {\\n  .styles-module_container__GBNxC rect {\\n    stroke: rgba(255, 255, 255, 0.04);\\n  }\\n}\\n\\n.styles-module_scrollContainer__-bJC8 {\\n  max-width: 100%;\\n  overflow-x: auto;\\n  overflow-y: hidden;\\n}\\n\\n.styles-module_calendar__sT1ND {\\n  display: block; /* SVGs are inline-block by default */\\n  overflow: visible; /* Weekday labels are rendered left of the container */\\n}\\n\\n.styles-module_calendar__sT1ND text {\\n  fill: currentColor;\\n}\\n\\n.styles-module_footer__ZQ-Bl {\\n  display: flex;\\n  flex-wrap: wrap;\\n  gap: 4px 16px;\\n  white-space: nowrap;\\n}\\n\\n.styles-module_legendColors__kFY2e {\\n  margin-left: auto;\\n  display: flex;\\n  align-items: center;\\n  gap: 3px;\\n}\\n\\n@keyframes styles-module_loadingAnimation__V0w3h {\\n  0% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n  50% {\\n    fill: var(--react-activity-calendar-loading-active);\\n  }\\n  100% {\\n    fill: var(--react-activity-calendar-loading);\\n  }\\n}\\n\";\nvar styles = {\n    \"container\": \"styles-module_container__GBNxC\",\n    \"scrollContainer\": \"styles-module_scrollContainer__-bJC8\",\n    \"calendar\": \"styles-module_calendar__sT1ND\",\n    \"footer\": \"styles-module_footer__ZQ-Bl\",\n    \"legendColors\": \"styles-module_legendColors__kFY2e\",\n    \"loadingAnimation\": \"styles-module_loadingAnimation__V0w3h\"\n};\nstyleInject(css_248z);\nfunction groupByWeeks(activities, weekStart = 0 // 0 = Sunday\n) {\n    if (activities.length === 0) {\n        return [];\n    }\n    const normalizedActivities = fillHoles(activities);\n    // Determine the first date of the calendar. If the first date is not the\n    // set start weekday, the selected weekday one week earlier is used.\n    const firstDate = dateFns.parseISO(normalizedActivities[0].date);\n    const firstCalendarDate = dateFns.getDay(firstDate) === weekStart ? firstDate : dateFns.subWeeks(dateFns.nextDay(firstDate, weekStart), 1);\n    // To correctly group activities by week, it is necessary to left-pad the list\n    // because the first date might not be set start weekday.\n    const paddedActivities = [\n        ...Array(dateFns.differenceInCalendarDays(firstDate, firstCalendarDate)).fill(undefined),\n        ...normalizedActivities\n    ];\n    const numberOfWeeks = Math.ceil(paddedActivities.length / 7);\n    // Finally, group activities by week\n    return Array(numberOfWeeks).fill(undefined).map((_, weekIndex)=>paddedActivities.slice(weekIndex * 7, weekIndex * 7 + 7));\n}\n/**\n * The calendar expects a continuous sequence of days,\n * so fill gaps with empty activity data.\n */ function fillHoles(activities) {\n    const dateMap = {};\n    for (const activity of activities){\n        dateMap[activity.date] = activity;\n    }\n    return dateFns.eachDayOfInterval({\n        start: dateFns.parseISO(activities[0].date),\n        end: dateFns.parseISO(activities[activities.length - 1].date)\n    }).map((day)=>{\n        const date = dateFns.formatISO(day, {\n            representation: \"date\"\n        });\n        if (dateMap[date]) {\n            return dateMap[date];\n        }\n        return {\n            date,\n            count: 0,\n            level: 0\n        };\n    });\n}\nfunction getMonthLabels(weeks, monthNames = DEFAULT_MONTH_LABELS) {\n    return weeks.reduce((labels, week, weekIndex)=>{\n        const firstActivity = week.find((activity)=>activity !== undefined);\n        if (!firstActivity) {\n            throw new Error(`Unexpected error: Week ${weekIndex + 1} is empty: [${week}].`);\n        }\n        const month = monthNames[dateFns.getMonth(dateFns.parseISO(firstActivity.date))];\n        const prevLabel = labels[labels.length - 1];\n        if (weekIndex === 0 || prevLabel.label !== month) {\n            return [\n                ...labels,\n                {\n                    weekIndex,\n                    label: month\n                }\n            ];\n        }\n        return labels;\n    }, []).filter(({ weekIndex }, index, labels)=>{\n        // Labels should only be shown if there is \"enough\" space (data).\n        // This is a naive implementation that does not take the block size,\n        // font size etc. into account.\n        const minWeeks = 3;\n        // Skip the first month label if there is not enough space to the next one.\n        if (index === 0) {\n            return labels[1] && labels[1].weekIndex - weekIndex >= minWeeks;\n        }\n        // Skip the last month label the there is not enough data in that month to\n        // avoid overflowing the calendar on the right.\n        if (index === labels.length - 1) {\n            return weeks.slice(weekIndex).length >= minWeeks;\n        }\n        return true;\n    });\n}\nfunction getClassName(name, styles) {\n    if (styles) {\n        return `${NAMESPACE}__${name} ${styles}`;\n    }\n    return `${NAMESPACE}__${name}`;\n}\nfunction generateEmptyData() {\n    const year = new Date().getFullYear();\n    const days = dateFns.eachDayOfInterval({\n        start: new Date(year, 0, 1),\n        end: new Date(year, 11, 31)\n    });\n    return days.map((date)=>({\n            date: dateFns.formatISO(date, {\n                representation: \"date\"\n            }),\n            count: 0,\n            level: 0\n        }));\n}\nfunction maxWeekdayLabelLength(firstWeek, weekStart, labels, fontSize) {\n    return firstWeek.reduce((maxLength, _, index)=>{\n        if (index % 2 !== 0) {\n            const dayIndex = (index + weekStart) % 7;\n            const curLength = Math.ceil(calcTextDimensions(labels[dayIndex], fontSize).width);\n            return Math.max(maxLength, curLength);\n        }\n        return maxLength;\n    }, 0);\n}\nfunction calcTextDimensions(text, fontSize) {\n    if (typeof document === \"undefined\" || \"undefined\" === \"undefined\") {\n        throw new Error(\"calcTextDimensions() requires browser APIs\");\n    }\n    if (fontSize < 1) {\n        throw new RangeError(\"fontSize must be positive\");\n    }\n    if (text.length === 0) {\n        return {\n            width: 0,\n            height: 0\n        };\n    }\n    const namespace = \"http://www.w3.org/2000/svg\";\n    const svg = document.createElementNS(namespace, \"svg\");\n    svg.style.position = \"absolute\";\n    svg.style.visibility = \"hidden\";\n    svg.style.fontFamily = window.getComputedStyle(document.body).fontFamily;\n    svg.style.fontSize = `${fontSize}px`;\n    const textNode = document.createElementNS(namespace, \"text\");\n    textNode.textContent = text;\n    svg.appendChild(textNode);\n    document.body.appendChild(svg);\n    const boundingBox = textNode.getBBox();\n    document.body.removeChild(svg);\n    return {\n        width: boundingBox.width,\n        height: boundingBox.height\n    };\n}\nfunction createTheme(input, size = 5) {\n    const defaultTheme = createDefaultTheme(size);\n    if (input) {\n        validateTheme(input, size);\n        input.light = input.light ?? defaultTheme.light;\n        input.dark = input.dark ?? defaultTheme.dark;\n        return {\n            light: isColorScale(input.light, size) ? input.light : createColorScale(input.light, size),\n            dark: isColorScale(input.dark, size) ? input.dark : createColorScale(input.dark, size)\n        };\n    }\n    return defaultTheme;\n}\nfunction createDefaultTheme(size) {\n    return {\n        light: createColorScale([\n            \"hsl(0, 0%, 92%)\",\n            \"hsl(0, 0%, 26%)\"\n        ], size),\n        dark: createColorScale([\n            \"hsl(0, 0%, 20%)\",\n            \"hsl(0, 0%, 92%)\"\n        ], size)\n    };\n}\nfunction validateTheme(input, size) {\n    if (typeof input !== \"object\" || input.light === undefined && input.dark === undefined) {\n        throw new Error(`The theme object must contain at least one of the fields \"light\" and \"dark\" with exactly 2 or ${size} colors respectively.`);\n    }\n    if (input.light) {\n        const { length } = input.light;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.light must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n    if (input.dark) {\n        const { length } = input.dark;\n        if (length !== 2 && length !== size) {\n            throw new Error(`theme.dark must contain exactly 2 or ${size} colors, ${length} passed.`);\n        }\n    }\n}\nfunction isColorScale(colors, size) {\n    const invalidColor = colors.find((color)=>!chroma__default.default.valid(color));\n    if (invalidColor) {\n        throw new Error(`Invalid color \"${invalidColor}\" passed. All CSS color formats are accepted.`);\n    }\n    return colors.length === size;\n}\nfunction createColorScale(colors, size) {\n    return chroma__default.default.scale(colors).mode(\"lch\").colors(size);\n}\nconst ActivityCalendar = ({ data, blockMargin = 4, blockRadius = 2, blockSize = 12, colorScheme = undefined, eventHandlers = {}, fontSize = 14, hideColorLegend = false, hideMonthLabels = false, hideTotalCount = false, labels: labelsProp = undefined, maxLevel = 4, loading = false, renderBlock = undefined, showWeekdayLabels = false, style: styleProp = {}, theme: themeProp = undefined, totalCount: totalCountProp = undefined, weekStart = 0 // Sunday\n })=>{\n    maxLevel = Math.max(1, maxLevel);\n    const theme = createTheme(themeProp, maxLevel + 1);\n    const systemColorScheme = useColorScheme();\n    const colorScale = theme[colorScheme ?? systemColorScheme];\n    const useAnimation = !usePrefersReducedMotion();\n    // Calculating the weekday label offset only works in the browser.\n    // So disable SSR in this case.\n    const isClient = useIsClient();\n    if (showWeekdayLabels && !isClient) {\n        return null;\n    }\n    if (loading) {\n        data = generateEmptyData();\n    }\n    if (data.length === 0) {\n        return null;\n    }\n    const year = dateFns.getYear(dateFns.parseISO(data[0]?.date));\n    const weeks = groupByWeeks(data, weekStart);\n    const labels = Object.assign({}, DEFAULT_LABELS, labelsProp);\n    const labelHeight = hideMonthLabels ? 0 : fontSize + LABEL_MARGIN;\n    const weekdayLabelOffset = showWeekdayLabels ? maxWeekdayLabelLength(weeks[0], weekStart, labels.weekdays, fontSize) + LABEL_MARGIN : undefined;\n    function getDimensions() {\n        return {\n            width: weeks.length * (blockSize + blockMargin) - blockMargin,\n            height: labelHeight + (blockSize + blockMargin) * 7 - blockMargin\n        };\n    }\n    function getEventHandlers(activity) {\n        return Object.keys(eventHandlers).reduce((handlers, key)=>({\n                ...handlers,\n                [key]: (event)=>eventHandlers[key]?.(event)(activity)\n            }), {});\n    }\n    function renderCalendar() {\n        return weeks.map((week, weekIndex)=>week.map((activity, dayIndex)=>{\n                if (!activity) {\n                    return null;\n                }\n                if (activity.level < 0 || activity.level > maxLevel) {\n                    throw new RangeError(`Provided activity level ${activity.level} for ${activity.date} is out of range. It must be between 0 and ${maxLevel}.`);\n                }\n                const style = loading && useAnimation ? {\n                    animation: `${styles.loadingAnimation} 1.75s ease-in-out infinite`,\n                    animationDelay: `${weekIndex * 20 + dayIndex * 20}ms`\n                } : undefined;\n                const block = /*#__PURE__*/ React__default.default.createElement(\"rect\", _extends({}, getEventHandlers(activity), {\n                    x: 0,\n                    y: labelHeight + (blockSize + blockMargin) * dayIndex,\n                    width: blockSize,\n                    height: blockSize,\n                    rx: blockRadius,\n                    ry: blockRadius,\n                    fill: colorScale[activity.level],\n                    \"data-date\": activity.date,\n                    \"data-level\": activity.level,\n                    style: style\n                }));\n                return /*#__PURE__*/ React__default.default.createElement(React.Fragment, {\n                    key: activity.date\n                }, renderBlock ? renderBlock(block, activity) : block);\n            })).map((week, x)=>/*#__PURE__*/ React__default.default.createElement(\"g\", {\n                key: x,\n                transform: `translate(${(blockSize + blockMargin) * x}, 0)`\n            }, week));\n    }\n    function renderFooter() {\n        if (hideTotalCount && hideColorLegend) {\n            return null;\n        }\n        const totalCount = typeof totalCountProp === \"number\" ? totalCountProp : data.reduce((sum, activity)=>sum + activity.count, 0);\n        return /*#__PURE__*/ React__default.default.createElement(\"footer\", {\n            className: getClassName(\"footer\", styles.footer),\n            style: {\n                marginLeft: weekdayLabelOffset\n            }\n        }, loading && /*#__PURE__*/ React__default.default.createElement(\"div\", null, \"\\xa0\"), !loading && !hideTotalCount && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"count\")\n        }, labels.totalCount ? labels.totalCount.replace(\"{{count}}\", String(totalCount)).replace(\"{{year}}\", String(year)) : `${totalCount} activities in ${year}`), !loading && !hideColorLegend && /*#__PURE__*/ React__default.default.createElement(\"div\", {\n            className: getClassName(\"legend-colors\", styles.legendColors)\n        }, /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginRight: \"0.4em\"\n            }\n        }, labels?.legend?.less ?? \"Less\"), Array(maxLevel + 1).fill(undefined).map((_, level)=>/*#__PURE__*/ React__default.default.createElement(\"svg\", {\n                width: blockSize,\n                height: blockSize,\n                key: level\n            }, /*#__PURE__*/ React__default.default.createElement(\"rect\", {\n                width: blockSize,\n                height: blockSize,\n                fill: colorScale[level],\n                rx: blockRadius,\n                ry: blockRadius\n            }))), /*#__PURE__*/ React__default.default.createElement(\"span\", {\n            style: {\n                marginLeft: \"0.4em\"\n            }\n        }, labels?.legend?.more ?? \"More\")));\n    }\n    function renderLabels() {\n        if (!showWeekdayLabels && hideMonthLabels) {\n            return null;\n        }\n        return /*#__PURE__*/ React__default.default.createElement(React__default.default.Fragment, null, showWeekdayLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-weekday\")\n        }, weeks[0].map((_, index)=>{\n            if (index % 2 === 0) {\n                return null;\n            }\n            const dayIndex = (index + weekStart) % 7;\n            return /*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: -LABEL_MARGIN,\n                y: labelHeight + (blockSize + blockMargin) * index + blockSize / 2,\n                dominantBaseline: \"middle\",\n                textAnchor: \"end\",\n                key: index\n            }, labels.weekdays[dayIndex]);\n        })), !hideMonthLabels && /*#__PURE__*/ React__default.default.createElement(\"g\", {\n            className: getClassName(\"legend-month\")\n        }, getMonthLabels(weeks, labels.months).map(({ label, weekIndex })=>/*#__PURE__*/ React__default.default.createElement(\"text\", {\n                x: (blockSize + blockMargin) * weekIndex,\n                dominantBaseline: \"hanging\",\n                key: weekIndex\n            }, label))));\n    }\n    const { width, height } = getDimensions();\n    const containerStyles = {\n        fontSize,\n        ...useAnimation && {\n            [`--${NAMESPACE}-loading`]: colorScale[0],\n            [`--${NAMESPACE}-loading-active`]: colorScheme === \"light\" ? chroma__default.default(colorScale[0]).darken(0.3).hex() : chroma__default.default(colorScale[0]).brighten(0.25).hex()\n        }\n    };\n    return /*#__PURE__*/ React__default.default.createElement(\"article\", {\n        className: `${NAMESPACE} ${styles.container}`,\n        style: {\n            ...styleProp,\n            ...containerStyles\n        }\n    }, /*#__PURE__*/ React__default.default.createElement(\"div\", {\n        className: getClassName(\"scroll-container\", styles.scrollContainer)\n    }, /*#__PURE__*/ React__default.default.createElement(\"svg\", {\n        width: width,\n        height: height,\n        viewBox: `0 0 ${width} ${height}`,\n        className: getClassName(\"calendar\", styles.calendar),\n        style: {\n            marginLeft: weekdayLabelOffset\n        }\n    }, !loading && renderLabels(), renderCalendar())), renderFooter());\n};\nconst Skeleton = (props)=>/*#__PURE__*/ React__default.default.createElement(ActivityCalendar, _extends({\n        data: []\n    }, props));\nexports.Skeleton = Skeleton;\nexports[\"default\"] = ActivityCalendar; //# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvcmVhY3QtYWN0aXZpdHktY2FsZW5kYXIvYnVpbGQvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBTyxNQUFNQSxZQUFZO0FBQ2xCLE1BQU1DLGVBQWUsR0FBRTtBQUV2QixNQUFNQyx1QkFBdUI7SUFDbEM7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0lBQ0E7SUFDQTtJQUNBO0NBQ0Q7QUFFTSxNQUFNQyxpQkFBaUI7SUFDNUJDLFFBQVFGO0lBQ1JHLFVBQVU7UUFBQztRQUFPO1FBQU87UUFBTztRQUFPO1FBQU87UUFBTztLQUFNO0lBQzNEQyxZQUFZO0lBQ1pDLFFBQVE7UUFDTkMsTUFBTTtRQUNOQyxNQUFNO0lBQ1I7QUFDRjtBQ3hCTyxTQUFTQztJQUNkLE1BQU0sQ0FBQ0MsYUFBYUMsZUFBZSxHQUFHQyxNQUFBQSxRQUFRLENBQW1CO0lBRWpFLE1BQU1DLFdBQVlDLENBQUFBLFFBQStCSCxlQUFlRyxNQUFNQyxPQUFPLEdBQUcsU0FBUztJQUV6RkMsTUFBQUEsU0FBUyxDQUFDO1FBQ1IsTUFBTUMsYUFBYUMsT0FBT0MsVUFBVSxDQUFDO1FBQ3JDUixlQUFlTSxXQUFXRixPQUFPLEdBQUcsU0FBUztRQUU3Q0UsV0FBV0csZ0JBQWdCLENBQUMsVUFBVVA7UUFFdEMsT0FBTztZQUNMSSxXQUFXSSxtQkFBbUIsQ0FBQyxVQUFVUjs7T0FFMUMsRUFBRTtJQUVMLE9BQU9IO0FBQ1Q7QUNqQk8sU0FBU1k7SUFDZCxNQUFNLENBQUNDLFVBQVVDLFVBQVUsR0FBR1osTUFBQUEsUUFBUSxDQUFDO0lBRXZDSSxNQUFBQSxTQUFTLENBQUM7UUFDUlEsVUFBVTtPQUNULEVBQUU7SUFFTCxPQUFPRDtBQUNUO0FDUkEsTUFBTUUsUUFBUTtBQUVQLFNBQVNDO0lBQ2QsTUFBTSxDQUFDQyxzQkFBc0JDLHdCQUF3QixHQUFHaEIsTUFBQUEsUUFBUSxDQUFDO0lBRWpFSSxNQUFB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Q3BDLE1BQU07SUFBRyxHQUFLZ0UiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi4vc3JjL2NvbnN0YW50cy50cz9iMTNlIiwid2VicGFjazovL3BvcnRmb2xpby8uLi9zcmMvaG9va3MvdXNlQ29sb3JTY2hlbWUudHM/NzljNyIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi4vc3JjL2hvb2tzL3VzZUlzQ2xpZW50LnRzPzdlNTYiLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4uL3NyYy9ob29rcy91c2VQcmVmZXJzUmVkdWNlZE1vdGlvbi50cz83OTljIiwid2VicGFjazovL3BvcnRmb2xpby8uLi9ub2RlX21vZHVsZXMvLnBucG0vc3R5bGUtaW5qZWN0QDAuMy4wL25vZGVfbW9kdWxlcy9zdHlsZS1pbmplY3QvZGlzdC9zdHlsZS1pbmplY3QuZXMuanM/NjMwZSIsIndlYnBhY2s6Ly9wb3J0Zm9saW8vLi4vc3JjL3V0aWxzL2NhbGVuZGFyLnRzP2FiZTciLCJ3ZWJwYWNrOi8vcG9ydGZvbGlvLy4uL3NyYy91dGlscy90aGVtZS50cz83NmQ2Iiwid2VicGFjazovL3BvcnRmb2xpby8uLi9zcmMvY29tcG9uZW50L0FjdGl2aXR5Q2FsZW5kYXIudHN4PzRiODMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IE5BTUVTUEFDRSA9ICdyZWFjdC1hY3Rpdml0eS1jYWxlbmRhcic7XG5leHBvcnQgY29uc3QgTEFCRUxfTUFSR0lOID0gODsgLy8gcHhcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTU9OVEhfTEFCRUxTID0gW1xuICAnSmFuJyxcbiAgJ0ZlYicsXG4gICdNYXInLFxuICAnQXByJyxcbiAgJ01heScsXG4gICdKdW4nLFxuICAnSnVsJyxcbiAgJ0F1ZycsXG4gICdTZXAnLFxuICAnT2N0JyxcbiAgJ05vdicsXG4gICdEZWMnLFxuXTtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfTEFCRUxTID0ge1xuICBtb250aHM6IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuICB3ZWVrZGF5czogWydTdW4nLCAnTW9uJywgJ1R1ZScsICdXZWQnLCAnVGh1JywgJ0ZyaScsICdTYXQnXSxcbiAgdG90YWxDb3VudDogJ3t7Y291bnR9fSBhY3Rpdml0aWVzIGluIHt7eWVhcn19JyxcbiAgbGVnZW5kOiB7XG4gICAgbGVzczogJ0xlc3MnLFxuICAgIG1vcmU6ICdNb3JlJyxcbiAgfSxcbn07XG4iLCJpbXBvcnQgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlQ29sb3JTY2hlbWUoKSB7XG4gIGNvbnN0IFtjb2xvclNjaGVtZSwgc2V0Q29sb3JTY2hlbWVdID0gdXNlU3RhdGU8J2xpZ2h0JyB8ICdkYXJrJz4oJ2xpZ2h0Jyk7XG5cbiAgY29uc3Qgb25DaGFuZ2UgPSAoZXZlbnQ6IE1lZGlhUXVlcnlMaXN0RXZlbnQpID0+IHNldENvbG9yU2NoZW1lKGV2ZW50Lm1hdGNoZXMgPyAnZGFyaycgOiAnbGlnaHQnKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG1lZGlhUXVlcnkgPSB3aW5kb3cubWF0Y2hNZWRpYSgnKHByZWZlcnMtY29sb3Itc2NoZW1lOiBkYXJrKScpO1xuICAgIHNldENvbG9yU2NoZW1lKG1lZGlhUXVlcnkubWF0Y2hlcyA/ICdkYXJrJyA6ICdsaWdodCcpO1xuXG4gICAgbWVkaWFRdWVyeS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG5cbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgbWVkaWFRdWVyeS5yZW1vdmVFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgfTtcbiAgfSwgW10pO1xuXG4gIHJldHVybiBjb2xvclNjaGVtZTtcbn1cbiIsImltcG9ydCB7IHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VJc0NsaWVudCgpIHtcbiAgY29uc3QgW2lzQ2xpZW50LCBzZXRDbGllbnRdID0gdXNlU3RhdGUoZmFsc2UpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgc2V0Q2xpZW50KHRydWUpO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIGlzQ2xpZW50O1xufVxuIiwiaW1wb3J0IHsgdXNlRWZmZWN0LCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuY29uc3QgcXVlcnkgPSAnKHByZWZlcnMtcmVkdWNlZC1tb3Rpb246IHJlZHVjZSknO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24oKSB7XG4gIGNvbnN0IFtwcmVmZXJzUmVkdWNlZE1vdGlvbiwgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb25dID0gdXNlU3RhdGUodHJ1ZSk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBtZWRpYVF1ZXJ5ID0gd2luZG93Lm1hdGNoTWVkaWEocXVlcnkpO1xuICAgIHNldFByZWZlcnNSZWR1Y2VkTW90aW9uKG1lZGlhUXVlcnkubWF0Y2hlcyk7XG5cbiAgICBjb25zdCBvbkNoYW5nZSA9IChldmVudDogTWVkaWFRdWVyeUxpc3RFdmVudCkgPT4ge1xuICAgICAgc2V0UHJlZmVyc1JlZHVjZWRNb3Rpb24oZXZlbnQubWF0Y2hlcyk7XG4gICAgfTtcblxuICAgIG1lZGlhUXVlcnkuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIG1lZGlhUXVlcnkucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgIH07XG4gIH0sIFtdKTtcblxuICByZXR1cm4gcHJlZmVyc1JlZHVjZWRNb3Rpb247XG59XG4iLCJmdW5jdGlvbiBzdHlsZUluamVjdChjc3MsIHJlZikge1xuICBpZiAoIHJlZiA9PT0gdm9pZCAwICkgcmVmID0ge307XG4gIHZhciBpbnNlcnRBdCA9IHJlZi5pbnNlcnRBdDtcblxuICBpZiAoIWNzcyB8fCB0eXBlb2YgZG9jdW1lbnQgPT09ICd1bmRlZmluZWQnKSB7IHJldHVybjsgfVxuXG4gIHZhciBoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICB2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICBzdHlsZS50eXBlID0gJ3RleHQvY3NzJztcblxuICBpZiAoaW5zZXJ0QXQgPT09ICd0b3AnKSB7XG4gICAgaWYgKGhlYWQuZmlyc3RDaGlsZCkge1xuICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc3R5bGUsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBoZWFkLmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgfVxuXG4gIGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IHN0eWxlSW5qZWN0O1xuIiwiaW1wb3J0IHR5cGUgeyBEYXkgYXMgV2Vla0RheSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7XG4gIGRpZmZlcmVuY2VJbkNhbGVuZGFyRGF5cyxcbiAgZWFjaERheU9mSW50ZXJ2YWwsXG4gIGVuZE9mWWVhcixcbiAgZm9ybWF0SVNPLFxuICBnZXREYXksXG4gIGdldE1vbnRoLFxuICBuZXh0RGF5LFxuICBwYXJzZUlTTyxcbiAgc3RhcnRPZlllYXIsXG4gIHN1YldlZWtzLFxufSBmcm9tICdkYXRlLWZucyc7XG5cbmltcG9ydCB7IERFRkFVTFRfTU9OVEhfTEFCRUxTLCBOQU1FU1BBQ0UgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgQWN0aXZpdHksIFdlZWsgfSBmcm9tICcuLi90eXBlcyc7XG5cbmludGVyZmFjZSBNb250aExhYmVsIHtcbiAgd2Vla0luZGV4OiBudW1iZXI7XG4gIGxhYmVsOiBzdHJpbmc7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBncm91cEJ5V2Vla3MoXG4gIGFjdGl2aXRpZXM6IEFycmF5PEFjdGl2aXR5PixcbiAgd2Vla1N0YXJ0OiBXZWVrRGF5ID0gMCwgLy8gMCA9IFN1bmRheVxuKTogQXJyYXk8V2Vlaz4ge1xuICBpZiAoYWN0aXZpdGllcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBub3JtYWxpemVkQWN0aXZpdGllcyA9IGZpbGxIb2xlcyhhY3Rpdml0aWVzKTtcblxuICAvLyBEZXRlcm1pbmUgdGhlIGZpcnN0IGRhdGUgb2YgdGhlIGNhbGVuZGFyLiBJZiB0aGUgZmlyc3QgZGF0ZSBpcyBub3QgdGhlXG4gIC8vIHNldCBzdGFydCB3ZWVrZGF5LCB0aGUgc2VsZWN0ZWQgd2Vla2RheSBvbmUgd2VlayBlYXJsaWVyIGlzIHVzZWQuXG4gIGNvbnN0IGZpcnN0RGF0ZSA9IHBhcnNlSVNPKG5vcm1hbGl6ZWRBY3Rpdml0aWVzWzBdLmRhdGUpO1xuICBjb25zdCBmaXJzdENhbGVuZGFyRGF0ZSA9XG4gICAgZ2V0RGF5KGZpcnN0RGF0ZSkgPT09IHdlZWtTdGFydCA/IGZpcnN0RGF0ZSA6IHN1YldlZWtzKG5leHREYXkoZmlyc3REYXRlLCB3ZWVrU3RhcnQpLCAxKTtcblxuICAvLyBUbyBjb3JyZWN0bHkgZ3JvdXAgYWN0aXZpdGllcyBieSB3ZWVrLCBpdCBpcyBuZWNlc3NhcnkgdG8gbGVmdC1wYWQgdGhlIGxpc3RcbiAgLy8gYmVjYXVzZSB0aGUgZmlyc3QgZGF0ZSBtaWdodCBub3QgYmUgc2V0IHN0YXJ0IHdlZWtkYXkuXG4gIGNvbnN0IHBhZGRlZEFjdGl2aXRpZXMgPSBbXG4gICAgLi4uQXJyYXkoZGlmZmVyZW5jZUluQ2FsZW5kYXJEYXlzKGZpcnN0RGF0ZSwgZmlyc3RDYWxlbmRhckRhdGUpKS5maWxsKHVuZGVmaW5lZCksXG4gICAgLi4ubm9ybWFsaXplZEFjdGl2aXRpZXMsXG4gIF07XG5cbiAgY29uc3QgbnVtYmVyT2ZXZWVrcyA9IE1hdGguY2VpbChwYWRkZWRBY3Rpdml0aWVzLmxlbmd0aCAvIDcpO1xuXG4gIC8vIEZpbmFsbHksIGdyb3VwIGFjdGl2aXRpZXMgYnkgd2Vla1xuICByZXR1cm4gQXJyYXkobnVtYmVyT2ZXZWVrcylcbiAgICAuZmlsbCh1bmRlZmluZWQpXG4gICAgLm1hcCgoXywgd2Vla0luZGV4KSA9PiBwYWRkZWRBY3Rpdml0aWVzLnNsaWNlKHdlZWtJbmRleCAqIDcsIHdlZWtJbmRleCAqIDcgKyA3KSk7XG59XG5cbi8qKlxuICogVGhlIGNhbGVuZGFyIGV4cGVjdHMgYSBjb250aW51b3VzIHNlcXVlbmNlIG9mIGRheXMsXG4gKiBzbyBmaWxsIGdhcHMgd2l0aCBlbXB0eSBhY3Rpdml0eSBkYXRhLlxuICovXG5mdW5jdGlvbiBmaWxsSG9sZXMoYWN0aXZpdGllczogQXJyYXk8QWN0aXZpdHk+KTogQXJyYXk8QWN0aXZpdHk+IHtcbiAgY29uc3QgZGF0ZU1hcDogUmVjb3JkPHN0cmluZywgQWN0aXZpdHk+ID0ge307XG4gIGZvciAoY29uc3QgYWN0aXZpdHkgb2YgYWN0aXZpdGllcykge1xuICAgIGRhdGVNYXBbYWN0aXZpdHkuZGF0ZV0gPSBhY3Rpdml0eTtcbiAgfVxuXG4gIHJldHVybiBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IHBhcnNlSVNPKGFjdGl2aXRpZXNbMF0uZGF0ZSksXG4gICAgZW5kOiBwYXJzZUlTTyhhY3Rpdml0aWVzW2FjdGl2aXRpZXMubGVuZ3RoIC0gMV0uZGF0ZSksXG4gIH0pLm1hcChkYXkgPT4ge1xuICAgIGNvbnN0IGRhdGUgPSBmb3JtYXRJU08oZGF5LCB7IHJlcHJlc2VudGF0aW9uOiAnZGF0ZScgfSk7XG5cbiAgICBpZiAoZGF0ZU1hcFtkYXRlXSkge1xuICAgICAgcmV0dXJuIGRhdGVNYXBbZGF0ZV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGUsXG4gICAgICBjb3VudDogMCxcbiAgICAgIGxldmVsOiAwLFxuICAgIH07XG4gIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TW9udGhMYWJlbHMoXG4gIHdlZWtzOiBBcnJheTxXZWVrPixcbiAgbW9udGhOYW1lczogQXJyYXk8c3RyaW5nPiA9IERFRkFVTFRfTU9OVEhfTEFCRUxTLFxuKTogQXJyYXk8TW9udGhMYWJlbD4ge1xuICByZXR1cm4gd2Vla3NcbiAgICAucmVkdWNlPEFycmF5PE1vbnRoTGFiZWw+PigobGFiZWxzLCB3ZWVrLCB3ZWVrSW5kZXgpID0+IHtcbiAgICAgIGNvbnN0IGZpcnN0QWN0aXZpdHkgPSB3ZWVrLmZpbmQoYWN0aXZpdHkgPT4gYWN0aXZpdHkgIT09IHVuZGVmaW5lZCk7XG5cbiAgICAgIGlmICghZmlyc3RBY3Rpdml0eSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgZXJyb3I6IFdlZWsgJHt3ZWVrSW5kZXggKyAxfSBpcyBlbXB0eTogWyR7d2Vla31dLmApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBtb250aCA9IG1vbnRoTmFtZXNbZ2V0TW9udGgocGFyc2VJU08oZmlyc3RBY3Rpdml0eS5kYXRlKSldO1xuICAgICAgY29uc3QgcHJldkxhYmVsID0gbGFiZWxzW2xhYmVscy5sZW5ndGggLSAxXTtcblxuICAgICAgaWYgKHdlZWtJbmRleCA9PT0gMCB8fCBwcmV2TGFiZWwubGFiZWwgIT09IG1vbnRoKSB7XG4gICAgICAgIHJldHVybiBbLi4ubGFiZWxzLCB7IHdlZWtJbmRleCwgbGFiZWw6IG1vbnRoIH1dO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gbGFiZWxzO1xuICAgIH0sIFtdKVxuICAgIC5maWx0ZXIoKHsgd2Vla0luZGV4IH0sIGluZGV4LCBsYWJlbHMpID0+IHtcbiAgICAgIC8vIExhYmVscyBzaG91bGQgb25seSBiZSBzaG93biBpZiB0aGVyZSBpcyBcImVub3VnaFwiIHNwYWNlIChkYXRhKS5cbiAgICAgIC8vIFRoaXMgaXMgYSBuYWl2ZSBpbXBsZW1lbnRhdGlvbiB0aGF0IGRvZXMgbm90IHRha2UgdGhlIGJsb2NrIHNpemUsXG4gICAgICAvLyBmb250IHNpemUgZXRjLiBpbnRvIGFjY291bnQuXG4gICAgICBjb25zdCBtaW5XZWVrcyA9IDM7XG5cbiAgICAgIC8vIFNraXAgdGhlIGZpcnN0IG1vbnRoIGxhYmVsIGlmIHRoZXJlIGlzIG5vdCBlbm91Z2ggc3BhY2UgdG8gdGhlIG5leHQgb25lLlxuICAgICAgaWYgKGluZGV4ID09PSAwKSB7XG4gICAgICAgIHJldHVybiBsYWJlbHNbMV0gJiYgbGFiZWxzWzFdLndlZWtJbmRleCAtIHdlZWtJbmRleCA+PSBtaW5XZWVrcztcbiAgICAgIH1cblxuICAgICAgLy8gU2tpcCB0aGUgbGFzdCBtb250aCBsYWJlbCB0aGUgdGhlcmUgaXMgbm90IGVub3VnaCBkYXRhIGluIHRoYXQgbW9udGggdG9cbiAgICAgIC8vIGF2b2lkIG92ZXJmbG93aW5nIHRoZSBjYWxlbmRhciBvbiB0aGUgcmlnaHQuXG4gICAgICBpZiAoaW5kZXggPT09IGxhYmVscy5sZW5ndGggLSAxKSB7XG4gICAgICAgIHJldHVybiB3ZWVrcy5zbGljZSh3ZWVrSW5kZXgpLmxlbmd0aCA+PSBtaW5XZWVrcztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRDbGFzc05hbWUobmFtZTogc3RyaW5nLCBzdHlsZXM/OiBzdHJpbmcpOiBzdHJpbmcge1xuICBpZiAoc3R5bGVzKSB7XG4gICAgcmV0dXJuIGAke05BTUVTUEFDRX1fXyR7bmFtZX0gJHtzdHlsZXN9YDtcbiAgfVxuXG4gIHJldHVybiBgJHtOQU1FU1BBQ0V9X18ke25hbWV9YDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdlbmVyYXRlRW1wdHlEYXRhKCk6IEFycmF5PEFjdGl2aXR5PiB7XG4gIGNvbnN0IHllYXIgPSBuZXcgRGF0ZSgpLmdldEZ1bGxZZWFyKCk7XG4gIGNvbnN0IGRheXMgPSBlYWNoRGF5T2ZJbnRlcnZhbCh7XG4gICAgc3RhcnQ6IG5ldyBEYXRlKHllYXIsIDAsIDEpLFxuICAgIGVuZDogbmV3IERhdGUoeWVhciwgMTEsIDMxKSxcbiAgfSk7XG5cbiAgcmV0dXJuIGRheXMubWFwKGRhdGUgPT4gKHtcbiAgICBkYXRlOiBmb3JtYXRJU08oZGF0ZSwgeyByZXByZXNlbnRhdGlvbjogJ2RhdGUnIH0pLFxuICAgIGNvdW50OiAwLFxuICAgIGxldmVsOiAwLFxuICB9KSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZW5lcmF0ZVRlc3REYXRhKGFyZ3M6IHtcbiAgaW50ZXJ2YWw/OiB7IHN0YXJ0OiBEYXRlOyBlbmQ6IERhdGUgfTtcbiAgbWF4TGV2ZWw/OiBudW1iZXI7XG59KTogQXJyYXk8QWN0aXZpdHk+IHtcbiAgY29uc3QgbWF4Q291bnQgPSAyMDtcbiAgY29uc3QgbWF4TGV2ZWwgPSBhcmdzLm1heExldmVsID8gTWF0aC5tYXgoMSwgYXJncy5tYXhMZXZlbCkgOiA0O1xuICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuXG4gIGNvbnN0IGRheXMgPSBlYWNoRGF5T2ZJbnRlcnZhbChcbiAgICBhcmdzLmludGVydmFsID8/IHtcbiAgICAgIHN0YXJ0OiBzdGFydE9mWWVhcihub3cpLFxuICAgICAgZW5kOiBlbmRPZlllYXIobm93KSxcbiAgICB9LFxuICApO1xuXG4gIHJldHVybiBkYXlzLm1hcChkYXRlID0+IHtcbiAgICAvLyBUaGUgcmFuZG9tIGFjdGl2aXR5IGNvdW50IGlzIHNoaWZ0ZWQgYnkgdXAgdG8gODAlIHRvd2FyZHMgemVyby5cbiAgICBjb25zdCBjID0gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogbWF4Q291bnQgLSBNYXRoLnJhbmRvbSgpICogKDAuOCAqIG1heENvdW50KSk7XG4gICAgY29uc3QgY291bnQgPSBNYXRoLm1heCgwLCBjKTtcbiAgICBjb25zdCBsZXZlbCA9IE1hdGguY2VpbCgoY291bnQgLyBtYXhDb3VudCkgKiBtYXhMZXZlbCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgZGF0ZTogZm9ybWF0SVNPKGRhdGUsIHsgcmVwcmVzZW50YXRpb246ICdkYXRlJyB9KSxcbiAgICAgIGNvdW50LFxuICAgICAgbGV2ZWwsXG4gICAgfTtcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtYXhXZWVrZGF5TGFiZWxMZW5ndGgoXG4gIGZpcnN0V2VlazogV2VlayxcbiAgd2Vla1N0YXJ0OiBudW1iZXIsXG4gIGxhYmVsczogc3RyaW5nW10sXG4gIGZvbnRTaXplOiBudW1iZXIsXG4pOiBudW1iZXIge1xuICByZXR1cm4gZmlyc3RXZWVrLnJlZHVjZSgobWF4TGVuZ3RoLCBfLCBpbmRleCkgPT4ge1xuICAgIGlmIChpbmRleCAlIDIgIT09IDApIHtcbiAgICAgIGNvbnN0IGRheUluZGV4ID0gKGluZGV4ICsgd2Vla1N0YXJ0KSAlIDc7XG4gICAgICBjb25zdCBjdXJMZW5ndGggPSBNYXRoLmNlaWwoY2FsY1RleHREaW1lbnNpb25zKGxhYmVsc1tkYXlJbmRleF0sIGZvbnRTaXplKS53aWR0aCk7XG5cbiAgICAgIHJldHVybiBNYXRoLm1heChtYXhMZW5ndGgsIGN1ckxlbmd0aCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG1heExlbmd0aDtcbiAgfSwgMCk7XG59XG5cbmZ1bmN0aW9uIGNhbGNUZXh0RGltZW5zaW9ucyh0ZXh0OiBzdHJpbmcsIGZvbnRTaXplOiBudW1iZXIpIHtcbiAgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gJ3VuZGVmaW5lZCcgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NhbGNUZXh0RGltZW5zaW9ucygpIHJlcXVpcmVzIGJyb3dzZXIgQVBJcycpO1xuICB9XG5cbiAgaWYgKGZvbnRTaXplIDwgMSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdmb250U2l6ZSBtdXN0IGJlIHBvc2l0aXZlJyk7XG4gIH1cblxuICBpZiAodGV4dC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4geyB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG4gIH1cblxuICBjb25zdCBuYW1lc3BhY2UgPSAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnO1xuICBjb25zdCBzdmcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAnc3ZnJyk7XG5cbiAgc3ZnLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgc3ZnLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgc3ZnLnN0eWxlLmZvbnRGYW1pbHkgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5ib2R5KS5mb250RmFtaWx5O1xuICBzdmcuc3R5bGUuZm9udFNpemUgPSBgJHtmb250U2l6ZX1weGA7XG5cbiAgY29uc3QgdGV4dE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlLCAndGV4dCcpO1xuICB0ZXh0Tm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG5cbiAgc3ZnLmFwcGVuZENoaWxkKHRleHROb2RlKTtcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzdmcpO1xuICBjb25zdCBib3VuZGluZ0JveCA9IHRleHROb2RlLmdldEJCb3goKTtcblxuICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHN2Zyk7XG5cbiAgcmV0dXJuIHsgd2lkdGg6IGJvdW5kaW5nQm94LndpZHRoLCBoZWlnaHQ6IGJvdW5kaW5nQm94LmhlaWdodCB9O1xufVxuIiwiaW1wb3J0IGNocm9tYSBmcm9tICdjaHJvbWEtanMnO1xuXG5pbXBvcnQgeyBDb2xvciwgQ29sb3JTY2FsZSwgVGhlbWUsIFRoZW1lSW5wdXQgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVUaGVtZShpbnB1dD86IFRoZW1lSW5wdXQsIHNpemU6IG51bWJlciA9IDUpOiBUaGVtZSB7XG4gIGNvbnN0IGRlZmF1bHRUaGVtZSA9IGNyZWF0ZURlZmF1bHRUaGVtZShzaXplKTtcblxuICBpZiAoaW5wdXQpIHtcbiAgICB2YWxpZGF0ZVRoZW1lKGlucHV0LCBzaXplKTtcblxuICAgIGlucHV0LmxpZ2h0ID0gaW5wdXQubGlnaHQgPz8gZGVmYXVsdFRoZW1lLmxpZ2h0O1xuICAgIGlucHV0LmRhcmsgPSBpbnB1dC5kYXJrID8/IGRlZmF1bHRUaGVtZS5kYXJrO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGxpZ2h0OiBpc0NvbG9yU2NhbGUoaW5wdXQubGlnaHQsIHNpemUpID8gaW5wdXQubGlnaHQgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmxpZ2h0LCBzaXplKSxcbiAgICAgIGRhcms6IGlzQ29sb3JTY2FsZShpbnB1dC5kYXJrLCBzaXplKSA/IGlucHV0LmRhcmsgOiBjcmVhdGVDb2xvclNjYWxlKGlucHV0LmRhcmssIHNpemUpLFxuICAgIH07XG4gIH1cblxuICByZXR1cm4gZGVmYXVsdFRoZW1lO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVEZWZhdWx0VGhlbWUoc2l6ZTogbnVtYmVyKTogVGhlbWUge1xuICByZXR1cm4ge1xuICAgIGxpZ2h0OiBjcmVhdGVDb2xvclNjYWxlKFsnaHNsKDAsIDAlLCA5MiUpJywgJ2hzbCgwLCAwJSwgMjYlKSddLCBzaXplKSxcbiAgICBkYXJrOiBjcmVhdGVDb2xvclNjYWxlKFsnaHNsKDAsIDAlLCAyMCUpJywgJ2hzbCgwLCAwJSwgOTIlKSddLCBzaXplKSxcbiAgfTtcbn1cblxuZnVuY3Rpb24gdmFsaWRhdGVUaGVtZShpbnB1dDogVGhlbWVJbnB1dCwgc2l6ZTogbnVtYmVyKSB7XG4gIGlmICh0eXBlb2YgaW5wdXQgIT09ICdvYmplY3QnIHx8IChpbnB1dC5saWdodCA9PT0gdW5kZWZpbmVkICYmIGlucHV0LmRhcmsgPT09IHVuZGVmaW5lZCkpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVGhlIHRoZW1lIG9iamVjdCBtdXN0IGNvbnRhaW4gYXQgbGVhc3Qgb25lIG9mIHRoZSBmaWVsZHMgXCJsaWdodFwiIGFuZCBcImRhcmtcIiB3aXRoIGV4YWN0bHkgMiBvciAke3NpemV9IGNvbG9ycyByZXNwZWN0aXZlbHkuYCxcbiAgICApO1xuICB9XG5cbiAgaWYgKGlucHV0LmxpZ2h0KSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IGlucHV0LmxpZ2h0O1xuICAgIGlmIChsZW5ndGggIT09IDIgJiYgbGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0aGVtZS5saWdodCBtdXN0IGNvbnRhaW4gZXhhY3RseSAyIG9yICR7c2l6ZX0gY29sb3JzLCAke2xlbmd0aCBhcyBudW1iZXJ9IHBhc3NlZC5gLFxuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICBpZiAoaW5wdXQuZGFyaykge1xuICAgIGNvbnN0IHsgbGVuZ3RoIH0gPSBpbnB1dC5kYXJrO1xuICAgIGlmIChsZW5ndGggIT09IDIgJiYgbGVuZ3RoICE9PSBzaXplKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgIGB0aGVtZS5kYXJrIG11c3QgY29udGFpbiBleGFjdGx5IDIgb3IgJHtzaXplfSBjb2xvcnMsICR7bGVuZ3RoIGFzIG51bWJlcn0gcGFzc2VkLmAsXG4gICAgICApO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBpc0NvbG9yU2NhbGUoY29sb3JzOiBBcnJheTx1bmtub3duPiwgc2l6ZTogbnVtYmVyKTogY29sb3JzIGlzIENvbG9yU2NhbGUge1xuICBjb25zdCBpbnZhbGlkQ29sb3IgPSBjb2xvcnMuZmluZChjb2xvciA9PiAhY2hyb21hLnZhbGlkKGNvbG9yKSk7XG5cbiAgaWYgKGludmFsaWRDb2xvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBjb2xvciBcIiR7aW52YWxpZENvbG9yfVwiIHBhc3NlZC4gQWxsIENTUyBjb2xvciBmb3JtYXRzIGFyZSBhY2NlcHRlZC5gKTtcbiAgfVxuXG4gIHJldHVybiBjb2xvcnMubGVuZ3RoID09PSBzaXplO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVDb2xvclNjYWxlKGNvbG9yczogW2Zyb206IENvbG9yLCB0bzogQ29sb3JdLCBzaXplOiBudW1iZXIpOiBDb2xvclNjYWxlIHtcbiAgcmV0dXJuIGNocm9tYS5zY2FsZShjb2xvcnMpLm1vZGUoJ2xjaCcpLmNvbG9ycyhzaXplKTtcbn1cbiIsIid1c2UgY2xpZW50JztcblxuaW1wb3J0IGNocm9tYSBmcm9tICdjaHJvbWEtanMnO1xuaW1wb3J0IHR5cGUgeyBEYXkgYXMgV2Vla0RheSB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IGdldFllYXIsIHBhcnNlSVNPIH0gZnJvbSAnZGF0ZS1mbnMnO1xuaW1wb3J0IFJlYWN0LCB7IENTU1Byb3BlcnRpZXMsIEZyYWdtZW50LCBGdW5jdGlvbkNvbXBvbmVudCwgUmVhY3RFbGVtZW50IH0gZnJvbSAncmVhY3QnO1xuXG5pbXBvcnQgeyBERUZBVUxUX0xBQkVMUywgTEFCRUxfTUFSR0lOLCBOQU1FU1BBQ0UgfSBmcm9tICcuLi9jb25zdGFudHMnO1xuaW1wb3J0IHsgdXNlQ29sb3JTY2hlbWUgfSBmcm9tICcuLi9ob29rcy91c2VDb2xvclNjaGVtZSc7XG5pbXBvcnQgeyB1c2VJc0NsaWVudCB9IGZyb20gJy4uL2hvb2tzL3VzZUlzQ2xpZW50JztcbmltcG9ydCB7IHVzZVByZWZlcnNSZWR1Y2VkTW90aW9uIH0gZnJvbSAnLi4vaG9va3MvdXNlUHJlZmVyc1JlZHVjZWRNb3Rpb24nO1xuaW1wb3J0IHN0eWxlcyBmcm9tICcuLi9zdHlsZXMvc3R5bGVzLm1vZHVsZS5jc3MnO1xuaW1wb3J0IHtcbiAgQWN0aXZpdHksXG4gIEJsb2NrRWxlbWVudCxcbiAgRXZlbnRIYW5kbGVyTWFwLFxuICBMYWJlbHMsXG4gIFJlYWN0RXZlbnQsXG4gIFNWR1JlY3RFdmVudEhhbmRsZXIsXG4gIFRoZW1lSW5wdXQsXG59IGZyb20gJy4uL3R5cGVzJztcbmltcG9ydCB7XG4gIGdlbmVyYXRlRW1wdHlEYXRhLFxuICBnZXRDbGFzc05hbWUsXG4gIGdldE1vbnRoTGFiZWxzLFxuICBncm91cEJ5V2Vla3MsXG4gIG1heFdlZWtkYXlMYWJlbExlbmd0aCxcbn0gZnJvbSAnLi4vdXRpbHMvY2FsZW5kYXInO1xuaW1wb3J0IHsgY3JlYXRlVGhlbWUgfSBmcm9tICcuLi91dGlscy90aGVtZSc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvcHMge1xuICAvKipcbiAgICogTGlzdCBvZiBjYWxlbmRhciBlbnRyaWVzLiBFdmVyeSBgQWN0aXZpdHlgIG9iamVjdCByZXF1aXJlcyBhbiBJU08gODYwMVxuICAgKiBgZGF0ZWAgc3RyaW5nIGluIHRoZSBmb3JtYXQgYHl5eXktTU0tZGRgLCBhIGBjb3VudGAgcHJvcGVydHkgd2l0aCB0aGVcbiAgICogYW1vdW50IG9mIHRyYWNrZWQgZGF0YSBhbmQgYSBgbGV2ZWxgIHByb3BlcnR5IGluIHRoZSByYW5nZSBgMC1tYXhMZXZlbGBcbiAgICogdG8gc3BlY2lmeSBhY3Rpdml0eSBpbnRlbnNpdHkuIFRoZSBgbWF4TGV2ZWxgIHByb3AgaXMgNCBieSBkZWZhdWx0LlxuICAgKlxuICAgKiBGb3IgbWlzc2luZyBkYXRlcywgbm8gYWN0aXZpdHkgaXMgYXNzdW1lZC4gVGhpcyBhbGxvd3MgY2hvb3NpbmcgdGhlIHN0YXJ0XG4gICAqIGFuZCBlbmQgZGF0ZSBvZiB0aGUgY2FsZW5kYXIgYXJiaXRyYXJpbHkgYnkgcGFzc2luZyBlbXB0eSBlbnRyaWVzIGFzIHRoZVxuICAgKiBmaXJzdCBhbmQgbGFzdCBpdGVtLlxuICAgKlxuICAgKiBFeGFtcGxlIG9iamVjdDpcbiAgICpcbiAgICogYGBganNvblxuICAgKiB7XG4gICAqICAgZGF0ZTogXCIyMDIxLTAyLTIwXCIsXG4gICAqICAgY291bnQ6IDE2LFxuICAgKiAgIGxldmVsOiAzXG4gICAqIH1cbiAgICogYGBgXG4gICAqL1xuICBkYXRhOiBBcnJheTxBY3Rpdml0eT47XG4gIC8qKlxuICAgKiBNYXJnaW4gYmV0d2VlbiBibG9ja3MgaW4gcGl4ZWxzLlxuICAgKi9cbiAgYmxvY2tNYXJnaW4/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBCb3JkZXIgcmFkaXVzIG9mIGJsb2NrcyBpbiBwaXhlbHMuXG4gICAqL1xuICBibG9ja1JhZGl1cz86IG51bWJlcjtcbiAgLyoqXG4gICAqIEJsb2NrIHNpemUgaW4gcGl4ZWxzLlxuICAgKi9cbiAgYmxvY2tTaXplPzogbnVtYmVyO1xuICAvKipcbiAgICogVXNlIGEgc3BlY2lmaWMgY29sb3Igc2NoZW1lIGluc3RlYWQgb2YgdGhlIHN5c3RlbSBvbmUuIFN1cHBvcnRlZCB2YWx1ZXNcbiAgICogYXJlIGAnbGlnaHQnYCBhbmQgYCdkYXJrJ2AuXG4gICAqL1xuICBjb2xvclNjaGVtZT86ICdsaWdodCcgfCAnZGFyayc7XG4gIC8qKlxuICAgKiBFdmVudCBoYW5kbGVycyB0byByZWdpc3RlciBmb3IgdGhlIFNWRyBgPHJlY3Q+YCBlbGVtZW50cyB0aGF0IGFyZSB1c2VkIHRvXG4gICAqIHJlbmRlciB0aGUgY2FsZW5kYXIgZGF5cy4gSGFuZGxlciBzaWduYXR1cmU6IGBldmVudCA9PiBhY3Rpdml0eSA9PiB2b2lkYFxuICAgKi9cbiAgZXZlbnRIYW5kbGVycz86IEV2ZW50SGFuZGxlck1hcDtcbiAgLyoqXG4gICAqIEZvbnQgc2l6ZSBmb3IgdGV4dCBpbiBwaXhlbHMuXG4gICAqL1xuICBmb250U2l6ZT86IG51bWJlcjtcbiAgLyoqXG4gICAqIFRvZ2dsZSB0byBoaWRlIGNvbG9yIGxlZ2VuZCBiZWxvdyBjYWxlbmRhci5cbiAgICovXG4gIGhpZGVDb2xvckxlZ2VuZD86IGJvb2xlYW47XG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gaGlkZSBtb250aCBsYWJlbHMgYWJvdmUgY2FsZW5kYXIuXG4gICAqL1xuICBoaWRlTW9udGhMYWJlbHM/OiBib29sZWFuO1xuICAvKipcbiAgICogVG9nZ2xlIHRvIGhpZGUgdGhlIHRvdGFsIGNvdW50IGJlbG93IGNhbGVuZGFyLlxuICAgKi9cbiAgaGlkZVRvdGFsQ291bnQ/OiBib29sZWFuO1xuICAvKipcbiAgICogTG9jYWxpemF0aW9uIHN0cmluZ3MgZm9yIGFsbCBjYWxlbmRhciBsYWJlbHMuXG4gICAqXG4gICAqIGB0b3RhbENvdW50YCBzdXBwb3J0cyB0aGUgcGxhY2Vob2xkZXJzIGB7e2NvdW50fX1gIGFuZCBge3t5ZWFyfX1gLlxuICAgKi9cbiAgbGFiZWxzPzogTGFiZWxzO1xuICAvKipcbiAgICogTWF4aW11bSBhY3Rpdml0eSBsZXZlbCAoemVybyBpbmRleGVkKS5cbiAgICovXG4gIG1heExldmVsPzogbnVtYmVyO1xuICAvKipcbiAgICogVG9nZ2xlIGZvciBsb2FkaW5nIHN0YXRlLiBgZGF0YWAgcHJvcGVydHkgd2lsbCBiZSBpZ25vcmVkIGlmIHNldC5cbiAgICovXG4gIGxvYWRpbmc/OiBib29sZWFuO1xuICAvKipcbiAgICogUmVuZGVyIHByb3AgZm9yIGNhbGVuZGFyIGJsb2NrcyAoYWN0aXZpdGllcykuIEZvciBleGFtcGxlLCB1c2VmdWwgdG8gd3JhcFxuICAgKiB0aGUgZWxlbWVudCB3aXRoIGEgdG9vbHRpcCBjb21wb25lbnQuIFVzZSBgUmVhY3QuY2xvbmVFbGVtZW50YCB0byBwYXNzXG4gICAqIGFkZGl0aW9uYWwgcHJvcHMgdG8gdGhlIGVsZW1lbnQgaWYgbmVjZXNzYXJ5LlxuICAgKi9cbiAgcmVuZGVyQmxvY2s/OiAoYmxvY2s6IEJsb2NrRWxlbWVudCwgYWN0aXZpdHk6IEFjdGl2aXR5KSA9PiBSZWFjdEVsZW1lbnQ7XG4gIC8qKlxuICAgKiBUb2dnbGUgdG8gc2hvdyB3ZWVrZGF5IGxhYmVscyBsZWZ0IHRvIHRoZSBjYWxlbmRhci5cbiAgICovXG4gIHNob3dXZWVrZGF5TGFiZWxzPzogYm9vbGVhbjtcbiAgLyoqXG4gICAqIFN0eWxlIG9iamVjdCB0byBwYXNzIHRvIGNvbXBvbmVudCBjb250YWluZXIuXG4gICAqL1xuICBzdHlsZT86IENTU1Byb3BlcnRpZXM7XG4gIC8qKlxuICAgKiBTZXQgdGhlIGNhbGVuZGFyIGNvbG9ycyBmb3IgdGhlIGxpZ2h0IGFuZCBkYXJrIHN5c3RlbSBjb2xvciBzY2hlbWUuXG4gICAqIERlZmluZSBlYWNoIGNvbG9yIHNjYWxlIGV4cGxpY2l0bHkgYnkgc2V0dGluZ3MgYWxsIGNvbG9ycyAoNSBwZXIgZGVmYXVsdClcbiAgICogb3IgcGFzcyBleGFjdGx5IHR3byBjb2xvcnMgKHRoZSBsb3dlc3QgYW5kIGhpZ2hlc3QgaW50ZW5zaXR5KSB0byBjYWxjdWxhdGVcbiAgICogYSBzaW5nbGUtaHVlIHNjYWxlLiBDb2xvcnMgY2FuIGJlIHNwZWNpZmllZCBpbiBhbnkgdmFsaWQgQ1NTIGZvcm1hdC5cbiAgICpcbiAgICogVGhlIGNvbG9ycyBmb3IgYXQgbGVhc3Qgb25lIHNjaGVtZSBtdXN0IGJlIHNldC4gSWYgdW5kZWZpbmVkLCB0aGUgZGVmYXVsdFxuICAgKiB0aGVtZSBpcyB1c2VkLiBCeSBkZWZhdWx0LCB0aGUgY2FsZW5kYXIgd2lsbCBzZWxlY3QgdGhlIGN1cnJlbnQgc3lzdGVtIGNvbG9yXG4gICAqIHNjaGVtZSwgYnV0IHlvdSBjYW4gZW5mb3JjZSBhIHNwZWNpZmljIHNjaGVtZSB3aXRoIHRoZSBgY29sb3JTY2hlbWVgIHByb3AuXG4gICAqXG4gICAqIEV4YW1wbGU6XG4gICAqXG4gICAqIGBgYHRzeFxuICAgKiA8QWN0aXZpdHlDYWxlbmRhclxuICAgKiAgIGRhdGE9e2RhdGF9XG4gICAqICAgdGhlbWU9e3tcbiAgICogICAgIGxpZ2h0OiBbJ2hzbCgwLCAwJSwgOTIlKScsICdmaXJlYnJpY2snXSxcbiAgICogICAgIGRhcms6IFsnIzMzMycsICdyZ2IoMjE0LCAxNiwgMTc0KSddLFxuICAgKiAgIH19XG4gICAqIC8+XG4gICAqIGBgYFxuICAgKlxuICAgKi9cbiAgdGhlbWU/OiBUaGVtZUlucHV0O1xuICAvKipcbiAgICogT3ZlcndyaXRlIHRoZSB0b3RhbCBhY3Rpdml0eSBjb3VudC5cbiAgICovXG4gIHRvdGFsQ291bnQ/OiBudW1iZXI7XG4gIC8qKlxuICAgKiBJbmRleCBvZiBkYXkgdG8gYmUgdXNlZCBhcyBzdGFydCBvZiB3ZWVrLiAwIHJlcHJlc2VudHMgU3VuZGF5LlxuICAgKi9cbiAgd2Vla1N0YXJ0PzogV2Vla0RheTtcbn1cblxuY29uc3QgQWN0aXZpdHlDYWxlbmRhcjogRnVuY3Rpb25Db21wb25lbnQ8UHJvcHM+ID0gKHtcbiAgZGF0YSxcbiAgYmxvY2tNYXJnaW4gPSA0LFxuICBibG9ja1JhZGl1cyA9IDIsXG4gIGJsb2NrU2l6ZSA9IDEyLFxuICBjb2xvclNjaGVtZSA9IHVuZGVmaW5lZCxcbiAgZXZlbnRIYW5kbGVycyA9IHt9LFxuICBmb250U2l6ZSA9IDE0LFxuICBoaWRlQ29sb3JMZWdlbmQgPSBmYWxzZSxcbiAgaGlkZU1vbnRoTGFiZWxzID0gZmFsc2UsXG4gIGhpZGVUb3RhbENvdW50ID0gZmFsc2UsXG4gIGxhYmVsczogbGFiZWxzUHJvcCA9IHVuZGVmaW5lZCxcbiAgbWF4TGV2ZWwgPSA0LFxuICBsb2FkaW5nID0gZmFsc2UsXG4gIHJlbmRlckJsb2NrID0gdW5kZWZpbmVkLFxuICBzaG93V2Vla2RheUxhYmVscyA9IGZhbHNlLFxuICBzdHlsZTogc3R5bGVQcm9wID0ge30sXG4gIHRoZW1lOiB0aGVtZVByb3AgPSB1bmRlZmluZWQsXG4gIHRvdGFsQ291bnQ6IHRvdGFsQ291bnRQcm9wID0gdW5kZWZpbmVkLFxuICB3ZWVrU3RhcnQgPSAwLCAvLyBTdW5kYXlcbn06IFByb3BzKSA9PiB7XG4gIG1heExldmVsID0gTWF0aC5tYXgoMSwgbWF4TGV2ZWwpO1xuXG4gIGNvbnN0IHRoZW1lID0gY3JlYXRlVGhlbWUodGhlbWVQcm9wLCBtYXhMZXZlbCArIDEpO1xuICBjb25zdCBzeXN0ZW1Db2xvclNjaGVtZSA9IHVzZUNvbG9yU2NoZW1lKCk7XG4gIGNvbnN0IGNvbG9yU2NhbGUgPSB0aGVtZVtjb2xvclNjaGVtZSA/PyBzeXN0ZW1Db2xvclNjaGVtZV07XG5cbiAgY29uc3QgdXNlQW5pbWF0aW9uID0gIXVzZVByZWZlcnNSZWR1Y2VkTW90aW9uKCk7XG5cbiAgLy8gQ2FsY3VsYXRpbmcgdGhlIHdlZWtkYXkgbGFiZWwgb2Zmc2V0IG9ubHkgd29ya3MgaW4gdGhlIGJyb3dzZXIuXG4gIC8vIFNvIGRpc2FibGUgU1NSIGluIHRoaXMgY2FzZS5cbiAgY29uc3QgaXNDbGllbnQgPSB1c2VJc0NsaWVudCgpO1xuICBpZiAoc2hvd1dlZWtkYXlMYWJlbHMgJiYgIWlzQ2xpZW50KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAobG9hZGluZykge1xuICAgIGRhdGEgPSBnZW5lcmF0ZUVtcHR5RGF0YSgpO1xuICB9XG5cbiAgaWYgKGRhdGEubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBjb25zdCB5ZWFyID0gZ2V0WWVhcihwYXJzZUlTTyhkYXRhWzBdPy5kYXRlKSk7XG4gIGNvbnN0IHdlZWtzID0gZ3JvdXBCeVdlZWtzKGRhdGEsIHdlZWtTdGFydCk7XG5cbiAgY29uc3QgbGFiZWxzID0gT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9MQUJFTFMsIGxhYmVsc1Byb3ApO1xuICBjb25zdCBsYWJlbEhlaWdodCA9IGhpZGVNb250aExhYmVscyA/IDAgOiBmb250U2l6ZSArIExBQkVMX01BUkdJTjtcblxuICBjb25zdCB3ZWVrZGF5TGFiZWxPZmZzZXQgPSBzaG93V2Vla2RheUxhYmVsc1xuICAgID8gbWF4V2Vla2RheUxhYmVsTGVuZ3RoKHdlZWtzWzBdLCB3ZWVrU3RhcnQsIGxhYmVscy53ZWVrZGF5cywgZm9udFNpemUpICsgTEFCRUxfTUFSR0lOXG4gICAgOiB1bmRlZmluZWQ7XG5cbiAgZnVuY3Rpb24gZ2V0RGltZW5zaW9ucygpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd2lkdGg6IHdlZWtzLmxlbmd0aCAqIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgLSBibG9ja01hcmdpbixcbiAgICAgIGhlaWdodDogbGFiZWxIZWlnaHQgKyAoYmxvY2tTaXplICsgYmxvY2tNYXJnaW4pICogNyAtIGJsb2NrTWFyZ2luLFxuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiBnZXRFdmVudEhhbmRsZXJzKGFjdGl2aXR5OiBBY3Rpdml0eSk6IFNWR1JlY3RFdmVudEhhbmRsZXIge1xuICAgIHJldHVybiAoXG4gICAgICBPYmplY3Qua2V5cyhldmVudEhhbmRsZXJzKSBhcyBBcnJheTxrZXlvZiBTVkdSZWN0RXZlbnRIYW5kbGVyPlxuICAgICkucmVkdWNlPFNWR1JlY3RFdmVudEhhbmRsZXI+KFxuICAgICAgKGhhbmRsZXJzLCBrZXkpID0+ICh7XG4gICAgICAgIC4uLmhhbmRsZXJzLFxuICAgICAgICBba2V5XTogKGV2ZW50OiBSZWFjdEV2ZW50PFNWR1JlY3RFbGVtZW50PikgPT4gZXZlbnRIYW5kbGVyc1trZXldPy4oZXZlbnQpKGFjdGl2aXR5KSxcbiAgICAgIH0pLFxuICAgICAge30sXG4gICAgKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbmRlckNhbGVuZGFyKCkge1xuICAgIHJldHVybiB3ZWVrc1xuICAgICAgLm1hcCgod2Vlaywgd2Vla0luZGV4KSA9PlxuICAgICAgICB3ZWVrLm1hcCgoYWN0aXZpdHksIGRheUluZGV4KSA9PiB7XG4gICAgICAgICAgaWYgKCFhY3Rpdml0eSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgaWYgKGFjdGl2aXR5LmxldmVsIDwgMCB8fCBhY3Rpdml0eS5sZXZlbCA+IG1heExldmVsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcbiAgICAgICAgICAgICAgYFByb3ZpZGVkIGFjdGl2aXR5IGxldmVsICR7YWN0aXZpdHkubGV2ZWx9IGZvciAke2FjdGl2aXR5LmRhdGV9IGlzIG91dCBvZiByYW5nZS4gSXQgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kICR7bWF4TGV2ZWx9LmAsXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnN0IHN0eWxlID1cbiAgICAgICAgICAgIGxvYWRpbmcgJiYgdXNlQW5pbWF0aW9uXG4gICAgICAgICAgICAgID8ge1xuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uOiBgJHtzdHlsZXMubG9hZGluZ0FuaW1hdGlvbn0gMS43NXMgZWFzZS1pbi1vdXQgaW5maW5pdGVgLFxuICAgICAgICAgICAgICAgICAgYW5pbWF0aW9uRGVsYXk6IGAke3dlZWtJbmRleCAqIDIwICsgZGF5SW5kZXggKiAyMH1tc2AsXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICAgIGNvbnN0IGJsb2NrID0gKFxuICAgICAgICAgICAgPHJlY3RcbiAgICAgICAgICAgICAgey4uLmdldEV2ZW50SGFuZGxlcnMoYWN0aXZpdHkpfVxuICAgICAgICAgICAgICB4PXswfVxuICAgICAgICAgICAgICB5PXtsYWJlbEhlaWdodCArIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiBkYXlJbmRleH1cbiAgICAgICAgICAgICAgd2lkdGg9e2Jsb2NrU2l6ZX1cbiAgICAgICAgICAgICAgaGVpZ2h0PXtibG9ja1NpemV9XG4gICAgICAgICAgICAgIHJ4PXtibG9ja1JhZGl1c31cbiAgICAgICAgICAgICAgcnk9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2FjdGl2aXR5LmxldmVsXX1cbiAgICAgICAgICAgICAgZGF0YS1kYXRlPXthY3Rpdml0eS5kYXRlfVxuICAgICAgICAgICAgICBkYXRhLWxldmVsPXthY3Rpdml0eS5sZXZlbH1cbiAgICAgICAgICAgICAgc3R5bGU9e3N0eWxlfVxuICAgICAgICAgICAgLz5cbiAgICAgICAgICApO1xuXG4gICAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICAgIDxGcmFnbWVudCBrZXk9e2FjdGl2aXR5LmRhdGV9PlxuICAgICAgICAgICAgICB7cmVuZGVyQmxvY2sgPyByZW5kZXJCbG9jayhibG9jaywgYWN0aXZpdHkpIDogYmxvY2t9XG4gICAgICAgICAgICA8L0ZyYWdtZW50PlxuICAgICAgICAgICk7XG4gICAgICAgIH0pLFxuICAgICAgKVxuICAgICAgLm1hcCgod2VlaywgeCkgPT4gKFxuICAgICAgICA8ZyBrZXk9e3h9IHRyYW5zZm9ybT17YHRyYW5zbGF0ZSgkeyhibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiB4fSwgMClgfT5cbiAgICAgICAgICB7d2Vla31cbiAgICAgICAgPC9nPlxuICAgICAgKSk7XG4gIH1cblxuICBmdW5jdGlvbiByZW5kZXJGb290ZXIoKSB7XG4gICAgaWYgKGhpZGVUb3RhbENvdW50ICYmIGhpZGVDb2xvckxlZ2VuZCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY29uc3QgdG90YWxDb3VudCA9XG4gICAgICB0eXBlb2YgdG90YWxDb3VudFByb3AgPT09ICdudW1iZXInXG4gICAgICAgID8gdG90YWxDb3VudFByb3BcbiAgICAgICAgOiBkYXRhLnJlZHVjZSgoc3VtLCBhY3Rpdml0eSkgPT4gc3VtICsgYWN0aXZpdHkuY291bnQsIDApO1xuXG4gICAgcmV0dXJuIChcbiAgICAgIDxmb290ZXJcbiAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2Zvb3RlcicsIHN0eWxlcy5mb290ZXIpfVxuICAgICAgICBzdHlsZT17eyBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgID5cbiAgICAgICAgey8qIFBsYWNlaG9sZGVyICovfVxuICAgICAgICB7bG9hZGluZyAmJiA8ZGl2PiZuYnNwOzwvZGl2Pn1cblxuICAgICAgICB7IWxvYWRpbmcgJiYgIWhpZGVUb3RhbENvdW50ICYmIChcbiAgICAgICAgICA8ZGl2IGNsYXNzTmFtZT17Z2V0Q2xhc3NOYW1lKCdjb3VudCcpfT5cbiAgICAgICAgICAgIHtsYWJlbHMudG90YWxDb3VudFxuICAgICAgICAgICAgICA/IGxhYmVscy50b3RhbENvdW50XG4gICAgICAgICAgICAgICAgICAucmVwbGFjZSgne3tjb3VudH19JywgU3RyaW5nKHRvdGFsQ291bnQpKVxuICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoJ3t7eWVhcn19JywgU3RyaW5nKHllYXIpKVxuICAgICAgICAgICAgICA6IGAke3RvdGFsQ291bnR9IGFjdGl2aXRpZXMgaW4gJHt5ZWFyfWB9XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG5cbiAgICAgICAgeyFsb2FkaW5nICYmICFoaWRlQ29sb3JMZWdlbmQgJiYgKFxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2xlZ2VuZC1jb2xvcnMnLCBzdHlsZXMubGVnZW5kQ29sb3JzKX0+XG4gICAgICAgICAgICA8c3BhbiBzdHlsZT17eyBtYXJnaW5SaWdodDogJzAuNGVtJyB9fT57bGFiZWxzPy5sZWdlbmQ/Lmxlc3MgPz8gJ0xlc3MnfTwvc3Bhbj5cbiAgICAgICAgICAgIHtBcnJheShtYXhMZXZlbCArIDEpXG4gICAgICAgICAgICAgIC5maWxsKHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgLm1hcCgoXywgbGV2ZWwpID0+IChcbiAgICAgICAgICAgICAgICA8c3ZnIHdpZHRoPXtibG9ja1NpemV9IGhlaWdodD17YmxvY2tTaXplfSBrZXk9e2xldmVsfT5cbiAgICAgICAgICAgICAgICAgIDxyZWN0XG4gICAgICAgICAgICAgICAgICAgIHdpZHRoPXtibG9ja1NpemV9XG4gICAgICAgICAgICAgICAgICAgIGhlaWdodD17YmxvY2tTaXplfVxuICAgICAgICAgICAgICAgICAgICBmaWxsPXtjb2xvclNjYWxlW2xldmVsXX1cbiAgICAgICAgICAgICAgICAgICAgcng9e2Jsb2NrUmFkaXVzfVxuICAgICAgICAgICAgICAgICAgICByeT17YmxvY2tSYWRpdXN9XG4gICAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgICAgIDwvc3ZnPlxuICAgICAgICAgICAgICApKX1cbiAgICAgICAgICAgIDxzcGFuIHN0eWxlPXt7IG1hcmdpbkxlZnQ6ICcwLjRlbScgfX0+e2xhYmVscz8ubGVnZW5kPy5tb3JlID8/ICdNb3JlJ308L3NwYW4+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgICl9XG4gICAgICA8L2Zvb3Rlcj5cbiAgICApO1xuICB9XG5cbiAgZnVuY3Rpb24gcmVuZGVyTGFiZWxzKCkge1xuICAgIGlmICghc2hvd1dlZWtkYXlMYWJlbHMgJiYgaGlkZU1vbnRoTGFiZWxzKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG5cbiAgICByZXR1cm4gKFxuICAgICAgPD5cbiAgICAgICAge3Nob3dXZWVrZGF5TGFiZWxzICYmIChcbiAgICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLXdlZWtkYXknKX0+XG4gICAgICAgICAgICB7d2Vla3NbMF0ubWFwKChfLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAoaW5kZXggJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBjb25zdCBkYXlJbmRleCA9IChpbmRleCArIHdlZWtTdGFydCkgJSA3O1xuXG4gICAgICAgICAgICAgIHJldHVybiAoXG4gICAgICAgICAgICAgICAgPHRleHRcbiAgICAgICAgICAgICAgICAgIHg9ey1MQUJFTF9NQVJHSU59XG4gICAgICAgICAgICAgICAgICB5PXtsYWJlbEhlaWdodCArIChibG9ja1NpemUgKyBibG9ja01hcmdpbikgKiBpbmRleCArIGJsb2NrU2l6ZSAvIDJ9XG4gICAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwibWlkZGxlXCJcbiAgICAgICAgICAgICAgICAgIHRleHRBbmNob3I9XCJlbmRcIlxuICAgICAgICAgICAgICAgICAga2V5PXtpbmRleH1cbiAgICAgICAgICAgICAgICA+XG4gICAgICAgICAgICAgICAgICB7bGFiZWxzLndlZWtkYXlzW2RheUluZGV4XX1cbiAgICAgICAgICAgICAgICA8L3RleHQ+XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9KX1cbiAgICAgICAgICA8L2c+XG4gICAgICAgICl9XG4gICAgICAgIHshaGlkZU1vbnRoTGFiZWxzICYmIChcbiAgICAgICAgICA8ZyBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnbGVnZW5kLW1vbnRoJyl9PlxuICAgICAgICAgICAge2dldE1vbnRoTGFiZWxzKHdlZWtzLCBsYWJlbHMubW9udGhzKS5tYXAoKHsgbGFiZWwsIHdlZWtJbmRleCB9KSA9PiAoXG4gICAgICAgICAgICAgIDx0ZXh0XG4gICAgICAgICAgICAgICAgeD17KGJsb2NrU2l6ZSArIGJsb2NrTWFyZ2luKSAqIHdlZWtJbmRleH1cbiAgICAgICAgICAgICAgICBkb21pbmFudEJhc2VsaW5lPVwiaGFuZ2luZ1wiXG4gICAgICAgICAgICAgICAga2V5PXt3ZWVrSW5kZXh9XG4gICAgICAgICAgICAgID5cbiAgICAgICAgICAgICAgICB7bGFiZWx9XG4gICAgICAgICAgICAgIDwvdGV4dD5cbiAgICAgICAgICAgICkpfVxuICAgICAgICAgIDwvZz5cbiAgICAgICAgKX1cbiAgICAgIDwvPlxuICAgICk7XG4gIH1cblxuICBjb25zdCB7IHdpZHRoLCBoZWlnaHQgfSA9IGdldERpbWVuc2lvbnMoKTtcblxuICBjb25zdCBjb250YWluZXJTdHlsZXMgPSB7XG4gICAgZm9udFNpemUsXG4gICAgLi4uKHVzZUFuaW1hdGlvbiAmJiB7XG4gICAgICBbYC0tJHtOQU1FU1BBQ0V9LWxvYWRpbmdgXTogY29sb3JTY2FsZVswXSxcbiAgICAgIFtgLS0ke05BTUVTUEFDRX0tbG9hZGluZy1hY3RpdmVgXTpcbiAgICAgICAgY29sb3JTY2hlbWUgPT09ICdsaWdodCdcbiAgICAgICAgICA/IGNocm9tYShjb2xvclNjYWxlWzBdKS5kYXJrZW4oMC4zKS5oZXgoKVxuICAgICAgICAgIDogY2hyb21hKGNvbG9yU2NhbGVbMF0pLmJyaWdodGVuKDAuMjUpLmhleCgpLFxuICAgIH0pLFxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPGFydGljbGVcbiAgICAgIGNsYXNzTmFtZT17YCR7TkFNRVNQQUNFfSAke3N0eWxlcy5jb250YWluZXJ9YH1cbiAgICAgIHN0eWxlPXt7IC4uLnN0eWxlUHJvcCwgLi4uY29udGFpbmVyU3R5bGVzIH19XG4gICAgPlxuICAgICAgPGRpdiBjbGFzc05hbWU9e2dldENsYXNzTmFtZSgnc2Nyb2xsLWNvbnRhaW5lcicsIHN0eWxlcy5zY3JvbGxDb250YWluZXIpfT5cbiAgICAgICAgPHN2Z1xuICAgICAgICAgIHdpZHRoPXt3aWR0aH1cbiAgICAgICAgICBoZWlnaHQ9e2hlaWdodH1cbiAgICAgICAgICB2aWV3Qm94PXtgMCAwICR7d2lkdGh9ICR7aGVpZ2h0fWB9XG4gICAgICAgICAgY2xhc3NOYW1lPXtnZXRDbGFzc05hbWUoJ2NhbGVuZGFyJywgc3R5bGVzLmNhbGVuZGFyKX1cbiAgICAgICAgICBzdHlsZT17eyBtYXJnaW5MZWZ0OiB3ZWVrZGF5TGFiZWxPZmZzZXQgfX1cbiAgICAgICAgPlxuICAgICAgICAgIHshbG9hZGluZyAmJiByZW5kZXJMYWJlbHMoKX1cbiAgICAgICAgICB7cmVuZGVyQ2FsZW5kYXIoKX1cbiAgICAgICAgPC9zdmc+XG4gICAgICA8L2Rpdj5cbiAgICAgIHtyZW5kZXJGb290ZXIoKX1cbiAgICA8L2FydGljbGU+XG4gICk7XG59O1xuXG5leHBvcnQgY29uc3QgU2tlbGV0b246IEZ1bmN0aW9uQ29tcG9uZW50PE9taXQ8UHJvcHMsICdkYXRhJz4+ID0gcHJvcHMgPT4gKFxuICA8QWN0aXZpdHlDYWxlbmRhciBkYXRhPXtbXX0gey4uLnByb3BzfSAvPlxuKTtcblxuZXhwb3J0IGRlZmF1bHQgQWN0aXZpdHlDYWxlbmRhcjtcbiJdLCJuYW1lcyI6WyJOQU1FU1BBQ0UiLCJMQUJFTF9NQVJHSU4iLCJERUZBVUxUX01PTlRIX0xBQkVMUyIsIkRFRkFVTFRfTEFCRUxTIiwibW9udGhzIiwid2Vla2RheXMiLCJ0b3RhbENvdW50IiwibGVnZW5kIiwibGVzcyIsIm1vcmUiLCJ1c2VDb2xvclNjaGVtZSIsImNvbG9yU2NoZW1lIiwic2V0Q29sb3JTY2hlbWUiLCJ1c2VTdGF0ZSIsIm9uQ2hhbmdlIiwiZXZlbnQiLCJtYXRjaGVzIiwidXNlRWZmZWN0IiwibWVkaWFRdWVyeSIsIndpbmRvdyIsIm1hdGNoTWVkaWEiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsInVzZUlzQ2xpZW50IiwiaXNDbGllbnQiLCJzZXRDbGllbnQiLCJxdWVyeSIsInVzZVByZWZlcnNSZWR1Y2VkTW90aW9uIiwicHJlZmVyc1JlZHVjZWRNb3Rpb24iLCJzZXRQcmVmZXJzUmVkdWNlZE1vdGlvbiIsInN0eWxlSW5qZWN0IiwiY3NzIiwicmVmIiwiaW5zZXJ0QXQiLCJkb2N1bWVudCIsImhlYWQiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsInN0eWxlIiwiY3JlYXRlRWxlbWVudCIsInR5cGUiLCJmaXJzdENoaWxkIiwiaW5zZXJ0QmVmb3JlIiwiYXBwZW5kQ2hpbGQiLCJzdHlsZVNoZWV0IiwiY3NzVGV4dCIsImNyZWF0ZVRleHROb2RlIiwiZ3JvdXBCeVdlZWtzIiwiYWN0aXZpdGllcyIsIndlZWtTdGFydCIsImxlbmd0aCIsIm5vcm1hbGl6ZWRBY3Rpdml0aWVzIiwiZmlsbEhvbGVzIiwiZmlyc3REYXRlIiwicGFyc2VJU08iLCJkYXRlIiwiZmlyc3RDYWxlbmRhckRhdGUiLCJnZXREYXkiLCJzdWJXZWVrcyIsIm5leHREYXkiLCJwYWRkZWRBY3Rpdml0aWVzIiwiQXJyYXkiLCJkaWZmZXJlbmNlSW5DYWxlbmRhckRheXMiLCJmaWxsIiwidW5kZWZpbmVkIiwibnVtYmVyT2ZXZWVrcyIsIk1hdGgiLCJjZWlsIiwibWFwIiwiXyIsIndlZWtJbmRleCIsInNsaWNlIiwiZGF0ZU1hcCIsImFjdGl2aXR5IiwiZWFjaERheU9mSW50ZXJ2YWwiLCJzdGFydCIsImVuZCIsImRheSIsImZvcm1hdElTTyIsInJlcHJlc2VudGF0aW9uIiwiY291bnQiLCJsZXZlbCIsImdldE1vbnRoTGFiZWxzIiwid2Vla3MiLCJtb250aE5hbWVzIiwicmVkdWNlIiwibGFiZWxzIiwid2VlayIsImZpcnN0QWN0aXZpdHkiLCJmaW5kIiwiRXJyb3IiLCJtb250aCIsImdldE1vbnRoIiwicHJldkxhYmVsIiwibGFiZWwiLCJmaWx0ZXIiLCJpbmRleCIsIm1pbldlZWtzIiwiZ2V0Q2xhc3NOYW1lIiwibmFtZSIsInN0eWxlcyIsImdlbmVyYXRlRW1wdHlEYXRhIiwieWVhciIsIkRhdGUiLCJnZXRGdWxsWWVhciIsImRheXMiLCJtYXhXZWVrZGF5TGFiZWxMZW5ndGgiLCJmaXJzdFdlZWsiLCJmb250U2l6ZSIsIm1heExlbmd0aCIsImRheUluZGV4IiwiY3VyTGVuZ3RoIiwiY2FsY1RleHREaW1lbnNpb25zIiwid2lkdGgiLCJtYXgiLCJ0ZXh0IiwiUmFuZ2VFcnJvciIsImhlaWdodCIsIm5hbWVzcGFjZSIsInN2ZyIsImNyZWF0ZUVsZW1lbnROUyIsInBvc2l0aW9uIiwidmlzaWJpbGl0eSIsImZvbnRGYW1pbHkiLCJnZXRDb21wdXRlZFN0eWxlIiwiYm9keSIsInRleHROb2RlIiwidGV4dENvbnRlbnQiLCJib3VuZGluZ0JveCIsImdldEJCb3giLCJyZW1vdmVDaGlsZCIsImNyZWF0ZVRoZW1lIiwiaW5wdXQiLCJzaXplIiwiZGVmYXVsdFRoZW1lIiwiY3JlYXRlRGVmYXVsdFRoZW1lIiwidmFsaWRhdGVUaGVtZSIsImxpZ2h0IiwiZGFyayIsImlzQ29sb3JTY2FsZSIsImNyZWF0ZUNvbG9yU2NhbGUiLCJjb2xvcnMiLCJpbnZhbGlkQ29sb3IiLCJjb2xvciIsImNocm9tYSIsInZhbGlkIiwic2NhbGUiLCJtb2RlIiwiQWN0aXZpdHlDYWxlbmRhciIsImRhdGEiLCJibG9ja01hcmdpbiIsImJsb2NrUmFkaXVzIiwiYmxvY2tTaXplIiwiZXZlbnRIYW5kbGVycyIsImhpZGVDb2xvckxlZ2VuZCIsImhpZGVNb250aExhYmVscyIsImhpZGVUb3RhbENvdW50IiwibGFiZWxzUHJvcCIsIm1heExldmVsIiwibG9hZGluZyIsInJlbmRlckJsb2NrIiwic2hvd1dlZWtkYXlMYWJlbHMiLCJzdHlsZVByb3AiLCJ0aGVtZSIsInRoZW1lUHJvcCIsInRvdGFsQ291bnRQcm9wIiwic3lzdGVtQ29sb3JTY2hlbWUiLCJjb2xvclNjYWxlIiwidXNlQW5pbWF0aW9uIiwiZ2V0WWVhciIsIk9iamVjdCIsImFzc2lnbiIsImxhYmVsSGVpZ2h0Iiwid2Vla2RheUxhYmVsT2Zmc2V0IiwiZ2V0RGltZW5zaW9ucyIsImdldEV2ZW50SGFuZGxlcnMiLCJrZXlzIiwiaGFuZGxlcnMiLCJrZXkiLCJyZW5kZXJDYWxlbmRhciIsImFuaW1hdGlvbiIsImxvYWRpbmdBbmltYXRpb24iLCJhbmltYXRpb25EZWxheSIsImJsb2NrIiwiUmVhY3QiLCJfZXh0ZW5kcyIsIngiLCJ5IiwicngiLCJyeSIsIkZyYWdtZW50IiwidHJhbnNmb3JtIiwicmVuZGVyRm9vdGVyIiwic3VtIiwiY2xhc3NOYW1lIiwiZm9vdGVyIiwibWFyZ2luTGVmdCIsInJlcGxhY2UiLCJTdHJpbmciLCJsZWdlbmRDb2xvcnMiLCJtYXJnaW5SaWdodCIsInJlbmRlckxhYmVscyIsImRvbWluYW50QmFzZWxpbmUiLCJ0ZXh0QW5jaG9yIiwiY29udGFpbmVyU3R5bGVzIiwiZGFya2VuIiwiaGV4IiwiYnJpZ2h0ZW4iLCJjb250YWluZXIiLCJzY3JvbGxDb250YWluZXIiLCJ2aWV3Qm94IiwiY2FsZW5kYXIiLCJTa2VsZXRvbiIsInByb3BzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/react-activity-calendar/build/index.js\n");

/***/ })

};
;